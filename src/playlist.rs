#![allow(dead_code, unused_imports)]
use regex::Regex;
use std::collections::{HashMap, HashSet};
use std::process::{Command};
use std::{
    fs,
    io::ErrorKind,
    str,
};

// checks if playlist videos are up to date
pub fn check_playlist(url: &String, path: &std::path::PathBuf) {
    let mut fetched_videos: Vec<String> = get_playlist_video_ids(url);
    let mut downloaded_videos: Vec<String> = Vec::new();

    // this ugly bastard extracts url of a video by getting
    // the brackets generated by yt-dlp
    if let Ok(files) = fs::read_dir(path) {
        for file in files {
            let file_name: &str = &file.unwrap().file_name().into_string().unwrap();
            let file_url = parse_url(file_name);
            downloaded_videos.push(file_url.into());
        }
    }

    let fetch_set: HashSet<String> = fetched_videos.iter().cloned().collect();
    let download_set: HashSet<String> = downloaded_videos.iter().cloned().collect();

    // this returns missing videos that should be downloaded
    fetched_videos.retain(|x| !download_set.contains(x));

    // this returns downloaded videos, not in playlist, that should be archived
    downloaded_videos.retain(|x| !fetch_set.contains(x));

    for video in fetched_videos {
        println!("Downloading missing video from playlist: {}", video);
        download_video(video, path);
    }

    for video in downloaded_videos {
        println!("Video removed from playlist should be archived: {}", video);
        // TODO: Archive system
    }
}

pub fn download_playlists(playlists: &HashMap<String, String>, path: &std::path::PathBuf) {
    for (url, title) in playlists.iter() {
        let path = path.join(title);
        println!("{path:?}");
        let audio_args = ["--extract-audio", "--audio-format", "opus"];

        Command::new("yt-dlp")
            .arg("--ignore-config") // ignore system config
            .args(audio_args) // extract only audio
            .arg("--path") // yt-dlp will just create the path if it's not there
            .arg(path)
            .arg(url)
            .output()
            .expect("Downloading playlists failed");
    }
}

pub fn add_playlist(playlists: &mut HashMap<String, String>, playlist_url: String) {
    // check if playlist already tracked
    if let Some(title) = playlists.get(&playlist_url) {
        println!("INFO: Playlist \"{title}\" is already tracked");
    } else {
        let playlist_title = get_playlist_title(playlist_url.clone());
        playlists.insert(playlist_url, playlist_title);
    }
}

pub fn remove_playlist(playlists: &mut HashMap<String, String>, playlist_url: String) {
    match playlists.remove(&playlist_url) {
        None => println!("Playlist is not tracked"),
        Some(title) => println!("{} removed", title),
    }
}

pub fn get_playlist_video_ids(url: &String) -> Vec<String> {
    let args = ["--flat-playlist", "--print", "id"];

    let output = Command::new("yt-dlp")
        .arg("--ignore-config")
        .args(args)
        .arg(url)
        .output()
        .unwrap_or_else(|err| {
            if err.kind() == ErrorKind::NotFound {
                panic!("Program yt-dlp is not found in your PATH");
            } else {
                panic!("Problem getting playlist ids: {err:?}");
            }
        });

    let urls: Vec<String> = str::from_utf8(&output.stdout)
        .expect("failed utf8 conversion")
        .lines()
        .map(|x| x.to_string())
        .collect();

    urls
}

pub fn get_playlist_title(playlist_url: String) -> String {
    let title_args = ["--flat-playlist", "--print", "playlist_title", "-I", "1:1"];

    let output = Command::new("yt-dlp")
        .arg("--ignore-config")
        .args(title_args)
        .arg(playlist_url)
        .output()
        .unwrap_or_else(|err| {
            if err.kind() == ErrorKind::NotFound {
                panic!("Program yt-dlp is not found in your PATH");
            } else {
                panic!("Problem getting playlist: {err:?}");
            }
        });

    let title = str::from_utf8(&output.stdout)
        .expect("failed utf8 conversion")
        .replace("\\n", "\n");

    title.trim().to_string()
}

pub fn download_video(url: String, path: &std::path::PathBuf) {
    let audio_args = ["--extract-audio", "--audio-format", "opus"];

    Command::new("yt-dlp")
        .arg("--ignore-config") // ignore system config
        .args(audio_args) // extract only audio
        .arg("--path") // yt-dlp will just create the path if it's not there
        .arg(path)
        .arg(url)
        .output()
        .unwrap_or_else(|err| {
            if err.kind() == ErrorKind::NotFound {
                panic!("Program yt-dlp is not found in your PATH");
            } else {
                panic!("Problem downloading video: {err:?}");
            }
        });
}

// finds the last bracket set and returns the contents
// yt-dlp by default will output title [url].extension
fn parse_url(name: & str) -> & str {
    // regex captures full brackets
    let regex = Regex::new(r"\[\w+\]").unwrap();
    let mut url: &str = "";

    // only use the last set of brackets
    if let Some(capture) = regex.find_iter(name).last() {
        let mut capture = capture.as_str().chars();
        capture.next(); // remove first bracket
        capture.next_back(); // then remove last bracket
        url = capture.as_str();
    } else {
        println!("No URL found in {}", name);
    };

    url
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn parse_normal() {
        let result = parse_url("oval [blazer].mp4");
        assert_eq!(result, "blazer");
    }
    
    #[test]
    fn parse_two_brackets() {
        let result = parse_url("[oval] [blazer].mp4");
        assert_eq!(result, "blazer");
    }
    
    #[test]
    fn parse_double_brackets() {
        let result = parse_url("oval [[blazer]].mp4");
        assert_eq!(result, "blazer");
    }
    
    #[test]
    fn parse_incomplete_brackets() {
        let result = parse_url("[oval [blazer].mp4");
        assert_eq!(result, "blazer");

        let result = parse_url("oval] [blazer].mp4");
        assert_eq!(result, "blazer");
    }
}